# IdeaForge -- Implementation Task Graph

**Generated by**: apex-task-decomposer
**Source ADR**: docs/architecture/adr.md (v1.0, 2026-02-12)
**Source Guardian**: docs/architecture/guardian-analysis.md (2026-02-12)
**Source PRD**: docs/product/prd.md (v1.0, 2026-02-12)
**Source Features**: docs/product/feature-breakdown.md (2026-02-12)
**Date**: 2026-02-12
**Total Tasks**: 42
**Estimated Total Effort**: ~162 hours (20 working days at 8 hours)

---

## Guardian Blocker Resolutions

Before any implementation begins, the following blocking issues from the guardian analysis are resolved in this task graph:

| Blocker | Resolution | Applied In |
|---------|-----------|------------|
| **BLOCK-01**: FTS5 content_rowid=rowid unstable across db.export()/reload | Use FTS5 rebuild on database load: `INSERT INTO ideas_fts(ideas_fts) VALUES('rebuild')`. Simpler than adding a stable integer alias column; adds <50ms startup cost for databases under 1000 ideas. | TASK-04 |
| **BLOCK-02**: PRD schema differs from ADR schema (tokens_used vs input_tokens/output_tokens, missing created_at on tags, missing ON DELETE CASCADE) | ADR schema is canonical. All tasks reference ADR Section 3.1 exclusively. PRD schema is superseded. | TASK-03, TASK-05 |
| **BLOCK-03**: Zod CreateIdeaSchema uses `description` but SQLite column is `content` | Rename `description` to `content` in CreateIdeaSchema. UI label can still say "Description" at the component level. | TASK-05 |

| Warning | Resolution | Applied In |
|---------|-----------|------------|
| **WARN-01**: persist() is fire-and-forget | Rewrite persist() to return a proper debounced promise. | TASK-04 |
| **WARN-02**: WAL mode not supported by sql.js | Remove PRAGMA journal_mode=WAL. | TASK-04 |
| **WARN-03**: FTS5 porter tokenizer needs verification | Verify in TASK-04; fallback to `tokenize='unicode61'`. | TASK-04 |
| **WARN-04**: Streaming + withRetry() may cause duplicate partials | Do NOT retry streaming requests. Only retry connection failures (pre-stream). | TASK-25 |
| **WARN-05**: XOR encryption for API keys is security theater | Store API keys in plaintext localStorage with honest UI disclosure. No fake encryption. | TASK-38 |
| **WARN-06**: Design system uses next/link | Use `import { Link } from 'react-router'` with `to` prop. | TASK-07 |
| **WARN-10**: Math.random() for IDs | Use `crypto.randomUUID()` everywhere. | TASK-05, TASK-09 |

---

## Authoritative Schema Notice

```
CRITICAL: The ADR (docs/architecture/adr.md Section 3.1) is the AUTHORITATIVE source
for all database schemas, types, and interfaces. Do NOT reference the PRD schema
(prd.md Section 4.3) -- it is outdated and conflicts with the ADR.
```
---

## Phase 1: Foundation (Weeks 1-2)

### TASK-01: Project Scaffolding

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 3 hours
- **Dependencies**: None (first task)
- **Guardian notes**: None
- **Description**: Initialize the Vite + React 19 + TypeScript 5.x project with Tailwind CSS 4, ESLint 9, and Prettier. Configure tsconfig with strict mode. Set up the path alias `@/` pointing to `src/`. Configure Vite for WASM support (exclude sql.js from optimizeDeps). Add the `.gitignore`, `package.json` scripts (dev, build, lint, typecheck, test), and the CI-ready project structure.
- **Acceptance criteria**:
  - `npm run dev` starts a working Vite dev server on localhost
  - `npm run build` produces a production build in `dist/`
  - `npm run typecheck` runs `tsc --noEmit` with zero errors
  - `npm run lint` runs ESLint with zero errors
  - TypeScript strict mode is enabled in `tsconfig.json`
  - `@/` path alias resolves correctly (e.g., `import { x } from '@/lib/utils'`)
  - Tailwind CSS 4 `@theme` block compiles (verify with a test class in App.tsx)
  - `sql.js` is excluded from Vite's `optimizeDeps`
  - Build target is `es2022`
  - Manual chunks configured per ADR Section 2.10
- **Files to create/modify**: `package.json`, `vite.config.ts`, `tsconfig.json`, `tsconfig.app.json`, `eslint.config.mjs` (flat config for ESLint 9), `.prettierrc`, `.gitignore` (update existing), `src/main.tsx`, `src/App.tsx`, `src/vite-env.d.ts`, `index.html`, `public/`
- **Technical notes**: Use `@vitejs/plugin-react` for React Fast Refresh. Tailwind 4 uses CSS-first `@theme` configuration in `globals.css`, NOT a `tailwind.config.js` file (per WARN-07). Install all production dependencies from ADR Section 11.1 and dev dependencies from Section 11.2 in this task.

---

### TASK-02: Design System Foundation

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 4 hours
- **Dependencies**: TASK-01
- **Guardian notes**: WARN-07 (use Tailwind v4 @theme, not JS config). WARN-10 (use crypto.randomUUID(), not Math.random()).
- **Description**: Set up the design system CSS tokens in `globals.css` using Tailwind 4 `@theme` blocks. Implement the core utility function `cn()` (clsx + tailwind-merge). Create the foundational UI components: Button (all 7 variants via CVA), Card, Input, Textarea, Badge (status + semantic variants). These are the building blocks for all features.
- **Acceptance criteria**:
  - `src/styles/globals.css` contains all design tokens from design-system.md (colors, typography, spacing, shadows) using `@theme` syntax
  - Light and dark mode tokens defined with CSS custom properties
  - `cn()` utility function exported from `src/lib/utils.ts`
  - Button component renders all 7 variants: primary, secondary, outline, ghost, destructive, forge, link
  - Button supports sizes: sm, md, lg
  - Card component renders with interactive and static variants
  - Input and Textarea components have consistent styling with focus rings
  - Badge component renders all status variants (spark, developing, refined, parked, archived) with correct colors
  - Badge component renders semantic variants (success, warning, destructive, info)
  - All components use CVA for type-safe variants
  - All components have explicit TypeScript return types on public functions
  - Barrel export from `src/components/ui/index.ts`
- **Files to create/modify**: `src/styles/globals.css`, `src/lib/utils.ts`, `src/components/ui/button.tsx`, `src/components/ui/card.tsx`, `src/components/ui/input.tsx`, `src/components/ui/textarea.tsx`, `src/components/ui/badge.tsx`, `src/components/ui/index.ts`
- **Technical notes**: Reference design-system.md for exact color values, variant definitions, and CVA configurations. Dark mode is default. Use `Inter` for sans font, `JetBrains Mono` for mono.

---

### TASK-03: Core TypeScript Types and Interfaces

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 2 hours
- **Dependencies**: TASK-01
- **Guardian notes**: WARN-09 (domain types referenced but never defined in ADR). BLOCK-02 (use ADR schema, not PRD schema -- ai_interactions has input_tokens + output_tokens, tags has created_at, all FKs have ON DELETE CASCADE).
- **Description**: Define all core TypeScript interfaces and type definitions used throughout the application. These are the shared contracts that all features depend on. Derive types from the ADR schema (Section 3.1) as the authoritative source.
- **Acceptance criteria**:
  - `IIdea` interface matches SQLite `ideas` table: id, title, content, status, created_at, updated_at, metadata
  - `IdeaStatus` is a discriminated union: `'spark' | 'developing' | 'refined' | 'parked' | 'archived'`
  - `ITag` interface: id, name, created_at (per ADR, NOT PRD which omits created_at)
  - `IIdeaTag` interface: idea_id, tag_id
  - `IConnection` interface: id, source_id, target_id, type, description, source, created_at
  - `ConnectionType` union: `'related' | 'builds_on' | 'contradicts' | 'merged_into'`
  - `ConnectionSource` union: `'manual' | 'ai_suggested' | 'ai_confirmed'`
  - `IAIInteraction` interface: id, idea_id, prompt, response, model, input_tokens, output_tokens, cost_estimate, created_at (per ADR, NOT PRD which uses tokens_used)
  - `IAIMessage` interface: role ('user' | 'assistant'), content, timestamp
  - `IAIConfig` interface: provider ('anthropic' | 'openai'), apiKey, model
  - `ISettings` interface: key, value, updated_at
  - All interfaces use `readonly` fields
  - All interfaces prefixed with `I` per coding standards
- **Files to create/modify**: `src/types/idea.ts`, `src/types/ai.ts`, `src/types/common.ts`, `src/types/index.ts` (barrel export)
- **Technical notes**: These types are pure type definitions -- no runtime code. They are imported by repositories, services, stores, and components. The `metadata` field on `IIdea` should be typed as `Record<string, unknown>` for now (per NOTE-10).

---

### TASK-04: SQLite-in-WASM Setup and Database Manager

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 8 hours
- **Dependencies**: TASK-01, TASK-03
- **Guardian notes**: BLOCK-01 (FTS5 rowid desync -- add rebuild on load). WARN-01 (persist() must return proper promise). WARN-02 (remove WAL pragma). WARN-03 (verify FTS5 porter tokenizer, have fallback). WARN-12 (design initialization sequence with skeleton UI).
- **Description**: Implement the DatabaseManager that initializes sql.js with WASM, creates or loads the database from IndexedDB, applies migrations, and handles persistence. This is the data foundation for the entire application. Must address all guardian blockers related to the database layer.
- **Acceptance criteria**:
  - sql.js WASM binary loads successfully from /sql.js/ directory in public/
  - On first load: creates a new database and applies initial migration (schema v1)
  - On subsequent loads: loads existing database binary from IndexedDB
  - FTS5 rebuild on every database load: After loading from IndexedDB, executes INSERT INTO ideas_fts(ideas_fts) VALUES('rebuild') to fix BLOCK-01
  - PRAGMA foreign_keys=ON is executed on every database open
  - NO PRAGMA journal_mode=WAL (per WARN-02 -- sql.js is in-memory)
  - FTS5 virtual table created with tokenize='porter unicode61'; if porter tokenizer unavailable, falls back to tokenize='unicode61' (per WARN-03)
  - persist() returns a proper debounced Promise that resolves on success and rejects on failure (per WARN-01 -- NOT fire-and-forget)
  - Auto-backup runs every 5 minutes, stores up to 3 rotated backups in IndexedDB
  - close() cleans up intervals and timers
  - createDatabaseManager() is a static factory function (no async constructor)
  - IndexedDB helpers (loadFromIndexedDB, saveToIndexedDB, pruneOldBackups) are fully implemented
  - Schema version is tracked in schema_version table
  - Migrations run inside transactions with rollback on failure
  - All database errors throw DatabaseError with context
  - Export function: db.export() returns Uint8Array for backup/export use
- **Files to create/modify**: src/database/database-manager.ts, src/database/migrations/index.ts, src/database/migrations/v001-initial-schema.ts, public/sql.js/ (copy sql.js WASM binary during build or postinstall)
- **Technical notes**: The initial schema SQL must match ADR Section 3.1 exactly, including all tables, FTS5 triggers, and indexes. The persist debounce should use a pattern where the returned Promise resolves/rejects with the actual IndexedDB operation result.

---

### TASK-05: Zod Validation Schemas

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 2 hours
- **Dependencies**: TASK-03
- **Guardian notes**: BLOCK-03 (rename description to content). WARN-10 (no Math.random).
- **Description**: Define Zod schemas for runtime validation of all user inputs. Fix BLOCK-03: CreateIdeaSchema field must be named content, NOT description, to match the SQLite column name.
- **Acceptance criteria**:
  - CreateIdeaSchema: title (string, 1-200 chars, required, trimmed), content (string, optional, default empty), tags (array of strings, optional, default empty)
  - Field named content NOT description (BLOCK-03 fix)
  - UpdateIdeaSchema: title, content, status, metadata (all optional partial updates)
  - AIConfigSchema: provider (enum anthropic/openai), apiKey (required string), model (required string)
  - SearchQuerySchema: query (string, 2-200 chars)
  - TagSchema: name (string, 1-50 chars, regex /^[a-zA-Z0-9_-]+$/ for FTS5 safety)
  - All schemas export z.infer<> types (CreateIdeaInput, UpdateIdeaInput, AIConfigInput, etc.)
  - User-friendly error messages on all validations
- **Files to create/modify**: src/lib/validation.ts
- **Technical notes**: Tag regex is critical for FTS5 safety -- special characters in tag names could break FTS queries. Schemas are used at the UI-service boundary for all user input.

---

### TASK-06: Error Hierarchy and Retry Utilities

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 2 hours
- **Dependencies**: TASK-01
- **Guardian notes**: None (implements ADR Section 4.4)
- **Description**: Implement the typed error class hierarchy and the withRetry exponential backoff utility. These are used by the database layer, AI service, and export service.
- **Acceptance criteria**:
  - IdeaForgeError base class with code, context, isRetryable properties
  - DatabaseError subclass (code: DATABASE_ERROR, isRetryable: true)
  - AIServiceError subclass (code: AI_SERVICE_ERROR, configurable isRetryable)
  - ValidationError subclass (code: VALIDATION_ERROR, isRetryable: false)
  - ExportError subclass (code: EXPORT_ERROR, isRetryable: true)
  - withRetry<T>(fn, options) generic async retry function
  - Respects isRetryable flag -- does NOT retry non-retryable errors
  - Exponential backoff: delay = min(baseDelayMs * 2^attempt, maxDelayMs)
  - Defaults: 3 retries, 500ms base delay, 10000ms max delay
  - All error classes have proper name property set
- **Files to create/modify**: src/lib/errors.ts, src/lib/retry.ts
- **Technical notes**: Match ADR Section 4.4 exactly. withRetry is used by AI service and database persist. Must be generic to support any async operation.

---

### TASK-07: Application Shell and Routing

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 5 hours
- **Dependencies**: TASK-01, TASK-02, TASK-04
- **Guardian notes**: WARN-06 (react-router Link with to prop, NOT next/link). WARN-12 (init flow with skeleton while WASM loads).
- **Description**: Build the AppShell layout component (sidebar + header + main content area) and configure React Router 7 routes with lazy loading. Implement the database initialization flow that shows a skeleton UI while sql.js WASM loads.
- **Acceptance criteria**:
  - AppShell component: sidebar (256px width), header (64px height), main content area with Outlet
  - Sidebar navigation: Ideas, Search, Settings links with Lucide icons
  - New Spark button prominently placed in header
  - Routes configured: / (redirect to /ideas), /ideas, /ideas/:id, /search, /settings, * (404)
  - All route components use lazy() for code splitting with Suspense boundaries
  - Uses react-router Link with to prop (WARN-06 fix -- NOT next/link href)
  - Responsive: sidebar collapses to hamburger menu below 768px breakpoint
  - Loading skeleton shown during sql.js WASM initialization
  - Init sequence: skeleton -> WASM load -> IndexedDB load -> migrations -> FTS rebuild -> hydrate store -> render app
  - DatabaseProvider context provides db instance to child components
- **Files to create/modify**: src/App.tsx (update), src/main.tsx (update), src/components/layouts/app-shell.tsx, src/components/layouts/loading-skeleton.tsx, src/features/not-found-view.tsx
- **Technical notes**: Use createBrowserRouter from react-router v7. DatabaseProvider wraps the router to provide the database instance via React context. The loading skeleton should match the final layout shape to minimize layout shift.

---

### TASK-08: Utility Libraries

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 2 hours
- **Dependencies**: TASK-01
- **Guardian notes**: WARN-10 (crypto.randomUUID, NOT Math.random). NOTE-09 (use Intl API over date-fns if sufficient).
- **Description**: Create utility modules for ID generation, date formatting, markdown helpers, and application constants. These are used throughout the entire application.
- **Acceptance criteria**:
  - generateId() uses crypto.randomUUID() (WARN-10 fix)
  - nowISO() returns current time as ISO 8601 string
  - formatRelativeTime(dateStr) using Intl.RelativeTimeFormat (e.g., "2 hours ago")
  - formatDate(dateStr) using Intl.DateTimeFormat for display dates
  - Constants exported: IDEA_STATUSES array, STATUS_COLORS map, MAX_TITLE_LENGTH (200), DEBOUNCE_MS (1000), PERSIST_DEBOUNCE_MS (2000), BACKUP_INTERVAL_MS (300000), MAX_BACKUPS (3)
  - If Intl APIs suffice for all date formatting needs, do NOT add date-fns dependency
- **Files to create/modify**: src/lib/id.ts, src/lib/date.ts, src/lib/markdown.ts, src/lib/constants.ts
- **Technical notes**: Evaluate whether Intl.RelativeTimeFormat and Intl.DateTimeFormat cover all formatting needs before importing date-fns. If they do, remove date-fns from package.json to save bundle size (per NOTE-09).

---

### TASK-09: Zustand Store with Slices

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 5 hours
- **Dependencies**: TASK-03, TASK-04, TASK-08
- **Guardian notes**: WARN-08 (no store type definitions in ADR -- define IIdeaSlice, IAISlice, IUISlice first). WARN-10 (crypto.randomUUID).
- **Description**: Implement the Zustand 5 store with the slice pattern. Define store type interfaces first (resolving WARN-08), then implement IdeaSlice, AISlice, and UISlice. The store connects the UI layer to the database repositories.
- **Acceptance criteria**:
  - IIdeaSlice interface defined: ideas array, currentIdea, filters, sortOrder, CRUD actions
  - IAISlice interface defined: messages, isStreaming, totalCost, modelConfig, chat actions
  - IUISlice interface defined: sidebarOpen, theme, toasts, modalStack, loading states, UI actions
  - IAppStore = IIdeaSlice & IAISlice & IUISlice combined type
  - IdeaSlice: loadIdeas, createIdea, updateIdea, deleteIdea, setCurrentIdea, setFilters, setSortOrder
  - AISlice: sendMessage, clearMessages, setStreaming, addCost, setConfig
  - UISlice: toggleSidebar, setTheme, addToast, removeToast, pushModal, popModal, setLoading
  - Store uses Zustand selectors to prevent unnecessary re-renders
  - All ID generation uses crypto.randomUUID()
  - Store exported as useAppStore hook with typed selectors
- **Files to create/modify**: src/store/index.ts, src/store/slices/idea-slice.ts, src/store/slices/ai-slice.ts, src/store/slices/ui-slice.ts, src/types/store.ts
- **Technical notes**: Zustand 5 uses the slice pattern where each slice is a function that receives set/get and returns a partial state object. The combined store merges all slices. Use immer middleware if state updates become complex, but start without it.

---

### TASK-10: Base Repository and Idea Repository

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 5 hours
- **Dependencies**: TASK-03, TASK-04, TASK-05, TASK-08
- **Guardian notes**: BLOCK-02 (use ADR schema exclusively). WARN-10 (crypto.randomUUID for all IDs).
- **Description**: Implement the BaseRepository with shared query helpers, then IdeaRepository for full CRUD operations on ideas. All SQL must use parameterized queries (no string interpolation).
- **Acceptance criteria**:
  - BaseRepository: execQuery, execRun, getOne, getMany helper methods wrapping sql.js API
  - IdeaRepository.create(input): validates with CreateIdeaSchema, generates UUID, inserts into ideas table, returns IIdea
  - IdeaRepository.getById(id): returns IIdea or null
  - IdeaRepository.getAll(filters?, sort?): returns IIdea[] with optional status filter and sort order
  - IdeaRepository.update(id, input): validates with UpdateIdeaSchema, updates fields, updates updated_at timestamp
  - IdeaRepository.delete(id): deletes idea (CASCADE handles related records)
  - IdeaRepository.findByStatus(status): returns IIdea[] filtered by status
  - IdeaRepository.count(): returns total idea count
  - All queries use parameterized statements (no string interpolation)
  - metadata field parsed from JSON string to Record<string, unknown> on read
  - metadata field serialized to JSON string on write
  - All IDs generated with crypto.randomUUID()
  - Timestamps use nowISO() from utility library
- **Files to create/modify**: src/database/repositories/base-repository.ts, src/database/repositories/idea-repository.ts
- **Technical notes**: The BaseRepository wraps the sql.js Database object and provides typed query helpers. IdeaRepository is the most-used repository -- it must handle the metadata JSON serialization correctly. ON DELETE CASCADE in the schema handles cleanup of related idea_tags, connections, and ai_interactions when an idea is deleted.

---

### TASK-11: Tag Repository and Settings Repository

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-10
- **Guardian notes**: BLOCK-02 (tags table has created_at per ADR, not PRD).
- **Description**: Implement TagRepository for tag CRUD and idea-tag associations, and SettingsRepository for key-value application settings.
- **Acceptance criteria**:
  - TagRepository.create(name): validates tag name, generates UUID, inserts tag with created_at
  - TagRepository.getAll(): returns all tags sorted by name
  - TagRepository.getByName(name): returns ITag or null
  - TagRepository.getForIdea(ideaId): returns tags associated with an idea via idea_tags join
  - TagRepository.addToIdea(ideaId, tagId): inserts into idea_tags (idempotent -- ignore if exists)
  - TagRepository.removeFromIdea(ideaId, tagId): deletes from idea_tags
  - TagRepository.search(partial): returns tags where name LIKE partial for autocomplete
  - TagRepository.delete(tagId): deletes tag (CASCADE handles idea_tags cleanup)
  - SettingsRepository.get(key): returns value or null
  - SettingsRepository.set(key, value): upsert with updated_at timestamp
  - SettingsRepository.getAll(): returns all settings as Record<string, string>
  - tags table includes created_at (per ADR, not PRD which omits it)
- **Files to create/modify**: src/database/repositories/tag-repository.ts, src/database/repositories/settings-repository.ts
- **Technical notes**: Tag names are validated with the TagSchema regex before database insertion. The autocomplete search uses SQL LIKE with the partial string. Settings are stored as key-value pairs and used for AI config, theme preference, onboarding state, etc.

---

### TASK-12: AI Interaction Repository and Connection Repository

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P1
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-10
- **Guardian notes**: BLOCK-02 (ai_interactions uses input_tokens + output_tokens per ADR, NOT tokens_used from PRD).
- **Description**: Implement AIInteractionRepository for storing AI chat history with cost tracking, and ConnectionRepository for idea-to-idea connections (created now for schema, primarily used in Phase 1.5).
- **Acceptance criteria**:
  - AIInteractionRepository.create(input): stores prompt, response, model, input_tokens, output_tokens, cost_estimate
  - AIInteractionRepository.getForIdea(ideaId): returns all interactions for an idea, ordered by created_at
  - AIInteractionRepository.getTotalCost(): returns sum of all cost_estimate values
  - AIInteractionRepository.getCostByModel(): returns cost breakdown grouped by model
  - ConnectionRepository.create(input): creates connection between two ideas with type and source
  - ConnectionRepository.getForIdea(ideaId): returns connections where idea is source or target
  - ConnectionRepository.delete(connectionId): removes a connection
  - ai_interactions columns: input_tokens, output_tokens (NOT tokens_used -- per ADR, BLOCK-02)
  - All foreign keys reference ideas(id) with ON DELETE CASCADE
- **Files to create/modify**: src/database/repositories/ai-interaction-repository.ts, src/database/repositories/connection-repository.ts
- **Technical notes**: The AI interaction repository is critical for cost tracking. The connection repository is built now because the schema exists in v1, but connections UI is Phase 1.5. Having the repository ready enables future AI-suggested connections.

---

### TASK-13: Foundation Unit Tests

- **Epic**: EPIC-001 (Foundation and Data Layer)
- **Priority**: P0
- **Estimated effort**: 5 hours
- **Dependencies**: TASK-04, TASK-05, TASK-06, TASK-10, TASK-11, TASK-12
- **Guardian notes**: None
- **Description**: Write comprehensive unit tests for the foundation layer: database manager, all repositories, Zod schemas, error classes, retry utility, and utility functions. Target 80%+ coverage on the data layer.
- **Acceptance criteria**:
  - DatabaseManager tests: init creates tables, loads from IndexedDB, FTS5 rebuild runs, persist returns promise, migrations apply correctly
  - IdeaRepository tests: create, read, update, delete, findByStatus, metadata JSON roundtrip
  - TagRepository tests: create, getAll, getForIdea, addToIdea, removeFromIdea, search autocomplete
  - AIInteractionRepository tests: create, getForIdea, getTotalCost, getCostByModel
  - ConnectionRepository tests: create, getForIdea, delete
  - SettingsRepository tests: get, set (insert and update), getAll
  - Zod schema tests: valid inputs pass, invalid inputs rejected with correct error messages, BLOCK-03 field name is content not description
  - Error hierarchy tests: correct codes, isRetryable flags, context propagation
  - withRetry tests: retries on retryable errors, stops on non-retryable, respects max retries, exponential backoff timing
  - Utility tests: generateId returns UUID format, nowISO returns ISO 8601, formatRelativeTime produces readable strings
  - Test database helper: createTestDatabase() utility for in-memory test databases
  - 80%+ code coverage on database/ and lib/ directories
- **Files to create/modify**: src/database/__tests__/database-manager.test.ts, src/database/repositories/__tests__/idea-repository.test.ts, tag-repository.test.ts, ai-interaction-repository.test.ts, connection-repository.test.ts, settings-repository.test.ts, src/lib/__tests__/validation.test.ts, errors.test.ts, retry.test.ts, src/test-utils/database.ts
- **Technical notes**: Use Vitest with an in-memory sql.js database for repository tests. The createTestDatabase() helper should create a fresh database with all migrations applied for each test. Tests must be fast (<5s total for the foundation suite).

---

## Phase 2: Spark Capture (Weeks 2-3)

### TASK-14: Toast Notification System

- **Epic**: EPIC-002 (Spark Capture)
- **Priority**: P0
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-02, TASK-07, TASK-09
- **Guardian notes**: WARN-10 (crypto.randomUUID for toast IDs, NOT Math.random).
- **Description**: Implement the toast notification system using Radix UI Toast primitive. This provides user feedback for spark capture, errors, status changes, and other actions throughout the app.
- **Acceptance criteria**:
  - Toast component wraps @radix-ui/react-toast with project styling
  - Toast variants: success (green), error (red), info (blue), warning (amber)
  - useToast() hook: addToast(message, variant, duration?), removeToast(id)
  - Toast IDs generated with crypto.randomUUID() (WARN-10 fix)
  - Default duration: 5 seconds, auto-dismiss with progress indicator
  - Multiple toasts stack vertically in bottom-right corner
  - Toast has close button for manual dismiss
  - Integrates with UISlice in Zustand store for state management
  - Maximum 3 visible toasts; older ones dismissed when limit exceeded
  - Toast provider wrapped at app root level
- **Files to create/modify**: src/components/ui/toast.tsx, src/hooks/use-toast.ts, src/components/providers/toast-provider.tsx
- **Technical notes**: Use @radix-ui/react-toast for the accessible primitive. Style with Tailwind + CVA for variants. The useToast hook connects to the UISlice in the Zustand store.

---

### TASK-15: Modal and Dialog Components

- **Epic**: EPIC-002 (Spark Capture)
- **Priority**: P0
- **Estimated effort**: 2 hours
- **Dependencies**: TASK-02
- **Guardian notes**: None
- **Description**: Create the reusable Modal component using Radix UI Dialog primitive. This is used by spark capture, delete confirmation, export dialog, and other modal interactions.
- **Acceptance criteria**:
  - Modal component wraps @radix-ui/react-dialog with project styling
  - Modal variants via CVA: default (medium), small, large, fullscreen-mobile
  - Overlay with backdrop blur and click-outside-to-close
  - Focus trap and keyboard navigation (Escape to close) via Radix built-ins
  - Modal.Header, Modal.Body, Modal.Footer subcomponents for consistent layout
  - ConfirmDialog component: title, message, confirm/cancel buttons with destructive variant
  - Proper ARIA attributes from Radix primitives
  - Animated enter/exit transitions
- **Files to create/modify**: src/components/ui/modal.tsx, src/components/ui/confirm-dialog.tsx
- **Technical notes**: Use @radix-ui/react-dialog for the accessible primitive. The asChild pattern via @radix-ui/react-slot enables composable trigger buttons. ConfirmDialog is a convenience wrapper used for delete confirmations.

---

### TASK-16: Tag Input Component with Autocomplete

- **Epic**: EPIC-002 (Spark Capture)
- **Priority**: P0
- **Estimated effort**: 4 hours
- **Dependencies**: TASK-02, TASK-11
- **Guardian notes**: None
- **Description**: Build the tag input component with autocomplete dropdown, tag creation, and tag removal. Used in both spark capture modal and the idea canvas metadata panel.
- **Acceptance criteria**:
  - TagInput component: text input with dropdown suggestions
  - Autocomplete queries TagRepository.search() on input change (debounced 200ms)
  - Creates new tags inline if typed tag does not exist
  - Tags displayed as removable badges below the input
  - Tag validation: 1-50 chars, alphanumeric/hyphen/underscore only (matches TagSchema)
  - Keyboard navigation: arrow keys to navigate suggestions, Enter to select, Backspace to remove last tag
  - Uses @radix-ui/react-popover for the autocomplete dropdown
  - Maximum tags per idea configurable (default: 10)
  - Duplicate tag prevention (case-insensitive)
- **Files to create/modify**: src/features/spark/components/tag-input.tsx, src/features/spark/hooks/use-tag-autocomplete.ts
- **Technical notes**: The autocomplete popover should appear below the input and filter suggestions as the user types. Tag creation should be seamless -- if the user types a tag that does not exist and presses Enter, it is created automatically.

---

### TASK-17: Spark Capture Modal

- **Epic**: EPIC-002 (Spark Capture)
- **Priority**: P0
- **Estimated effort**: 4 hours
- **Dependencies**: TASK-09, TASK-10, TASK-14, TASK-15, TASK-16
- **Guardian notes**: BLOCK-03 (content field, not description). WARN-10 (crypto.randomUUID).
- **Description**: Implement the Spark Capture Modal -- the primary way users create new ideas. Includes the form with title, optional content, and tags, plus validation and success feedback.
- **Acceptance criteria**:
  - SparkCaptureModal opens from header New Spark button and Ctrl+N keyboard shortcut
  - Form fields: title (required, focus on open), content (optional, labeled Description in UI but field name is content per BLOCK-03), tags (optional via TagInput)
  - Zod validation with CreateIdeaSchema on submit (field is content, not description)
  - On save: calls IdeaSlice.createIdea -> IdeaRepository.create -> persist()
  - Success: closes modal, shows success toast, new idea appears in dashboard
  - Error: displays inline validation errors, shows error toast for database failures
  - Cancel: closes modal, no data saved (no unsaved changes warning for sparks)
  - Form resets on each open
  - Keyboard: Enter in title moves to content, Ctrl+Enter submits from anywhere
  - Autofocus on title input when modal opens
- **Files to create/modify**: src/features/spark/components/spark-capture-modal.tsx, src/features/spark/components/spark-form.tsx, src/features/spark/hooks/use-spark-capture.ts
- **Technical notes**: The spark capture flow should feel instant -- target < 500ms from click to saved confirmation. The form uses the Zod CreateIdeaSchema for validation, which now has content (not description) per BLOCK-03.

---

### TASK-18: Ideas Dashboard

- **Epic**: EPIC-002 (Spark Capture)
- **Priority**: P0
- **Estimated effort**: 6 hours
- **Dependencies**: TASK-09, TASK-10, TASK-11, TASK-14, TASK-17
- **Guardian notes**: None
- **Description**: Build the Ideas Dashboard view -- the main screen users see when they open the app. Shows all ideas as cards in a responsive grid with status filtering, sorting, and navigation to the idea canvas.
- **Acceptance criteria**:
  - IdeasDashboard component at /ideas route
  - Responsive card grid layout: 1 column mobile, 2 columns tablet, 3 columns desktop
  - IdeaCard component: title, truncated content preview (first 120 chars), status badge, tags, relative timestamp
  - Click on card navigates to /ideas/:id (idea canvas)
  - Status filter bar: All, Spark, Developing, Refined, Parked, Archived (active filter highlighted)
  - Sort options dropdown: Newest first (default), Oldest first, Recently updated, Alphabetical
  - Empty state: friendly message with prompt to capture first spark (shown when no ideas exist)
  - Loading state: skeleton cards while data loads
  - Ideas loaded from IdeaSlice in Zustand store on mount
  - Idea count displayed in header or filter bar
  - Virtual scrolling with @tanstack/react-virtual when idea count > 100
- **Files to create/modify**: src/features/ideas/components/ideas-dashboard.tsx, src/features/ideas/components/idea-card.tsx, src/features/ideas/components/idea-filters.tsx, src/features/ideas/components/idea-sort.tsx, src/features/ideas/hooks/use-ideas.ts, src/features/ideas/index.ts, src/components/layouts/ideas-grid.tsx
- **Technical notes**: The dashboard is the app entry point. Performance is critical -- use React.memo on IdeaCard to prevent unnecessary re-renders. Use Zustand selectors to subscribe only to the ideas list, not the entire store. Virtual scrolling is only needed for 100+ ideas.

---

## Phase 3: Idea Canvas (Weeks 3-5)

### TASK-19: TipTap Editor Setup

- **Epic**: EPIC-003 (Idea Canvas)
- **Priority**: P0
- **Estimated effort**: 5 hours
- **Dependencies**: TASK-01, TASK-02
- **Guardian notes**: None
- **Description**: Set up TipTap 2.x rich text editor with markdown serialization, basic formatting toolbar, and placeholder text. Content is stored as markdown in the database but edited as rich text.
- **Acceptance criteria**:
  - TipTap editor component with @tiptap/react useEditor hook
  - Extensions: starter-kit (headings, bold, italic, lists, code, blockquote), tiptap-markdown, placeholder, link, code-block-lowlight
  - Markdown serialization: editor.storage.markdown.getMarkdown() on save
  - Markdown deserialization: load markdown content into editor on mount
  - Formatting toolbar: Bold, Italic, Headings (H1-H3), Bullet List, Numbered List, Code Block, Blockquote, Link
  - Toolbar buttons show active state when cursor is in formatted region
  - Placeholder text: "Start writing your idea..." when editor is empty
  - Code blocks with syntax highlighting via lowlight
  - Editor respects dark/light theme from design system
  - Editor content area has comfortable max-width for readability (prose)
- **Files to create/modify**: src/features/canvas/components/markdown-editor.tsx, src/features/canvas/hooks/use-editor.ts
- **Technical notes**: TipTap stores content as ProseMirror JSON internally, but we serialize to/from markdown for storage via tiptap-markdown extension. This ensures portable content. The editor should feel fast -- no lag on keystroke.

---

### TASK-20: Auto-Save with Debounce and Saved Indicator

- **Epic**: EPIC-003 (Idea Canvas)
- **Priority**: P0
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-10, TASK-19
- **Guardian notes**: None
- **Description**: Implement auto-save for the TipTap editor with 1-second debounce, visual saved indicator, and proper error handling for save failures.
- **Acceptance criteria**:
  - useAutoSave hook: watches editor content changes with 1s debounce
  - On change: extracts markdown via getMarkdown(), calls IdeaRepository.update(), triggers persist()
  - Saved indicator in header: "Saving..." during save, "Saved" with checkmark after success, "Save failed" with retry on error
  - Indicator shows relative time since last save (e.g., "Saved 2 min ago")
  - Does NOT save if content has not changed (compares with last saved content)
  - Handles rapid typing gracefully (debounce resets on each keystroke)
  - Save errors displayed via toast notification with retry option
  - Component unmount triggers immediate save of any pending changes
- **Files to create/modify**: src/features/canvas/hooks/use-auto-save.ts, src/features/canvas/components/save-indicator.tsx
- **Technical notes**: The auto-save debounce prevents excessive database writes during rapid typing. The 1s delay matches ADR Section 1.3. The save indicator provides essential user confidence that their work is persisted.

---

### TASK-21: Title Editor and Status Controls

- **Epic**: EPIC-003 (Idea Canvas)
- **Priority**: P1
- **Estimated effort**: 2 hours
- **Dependencies**: TASK-10, TASK-19
- **Guardian notes**: None
- **Description**: Implement the inline title editor and status dropdown for the idea canvas. Title is editable directly in the canvas header. Status changes trigger immediate save.
- **Acceptance criteria**:
  - TitleEditor: contentEditable or input element styled as heading, auto-saves on blur or Enter
  - Title validation: 1-200 characters (matches CreateIdeaSchema)
  - Status dropdown using @radix-ui/react-dropdown-menu
  - Status options: Spark, Developing, Refined, Parked, Archived with colored badges
  - Status change triggers immediate update via IdeaRepository.update() + persist()
  - Status change shows toast notification confirming the change
  - Title and status are part of the canvas header area, above the editor
- **Files to create/modify**: src/features/canvas/components/title-editor.tsx, src/features/canvas/components/status-dropdown.tsx
- **Technical notes**: The title editor should feel like editing a document title -- large font, no visible border until focused. The status dropdown uses the same Badge component variants from the design system.

---

### TASK-22: Metadata Panel

- **Epic**: EPIC-003 (Idea Canvas)
- **Priority**: P1
- **Estimated effort**: 4 hours
- **Dependencies**: TASK-11, TASK-16, TASK-21
- **Guardian notes**: None
- **Description**: Build the metadata sidebar panel for the idea canvas. Shows and allows editing of tags, dates, status, and idea statistics.
- **Acceptance criteria**:
  - MetadataPanel component: right sidebar (280px width) in canvas layout
  - Displays: status badge, created date, last updated date, word count, character count
  - Tag section: shows current tags as badges, TagInput component for adding/removing tags
  - Tags changes save immediately via TagRepository.addToIdea/removeFromIdea + persist()
  - Created/updated dates formatted with formatDate() utility
  - Collapsible on mobile (slides in from right)
  - Statistics update in real-time as user types in editor
  - Section headers with subtle styling matching design system
- **Files to create/modify**: src/features/canvas/components/metadata-panel.tsx
- **Technical notes**: The metadata panel provides quick access to idea properties without leaving the editor. Word/character count should be computed from the editor content, not raw markdown.

---

### TASK-23: Canvas Layout

- **Epic**: EPIC-003 (Idea Canvas)
- **Priority**: P0
- **Estimated effort**: 4 hours
- **Dependencies**: TASK-07, TASK-19, TASK-20, TASK-21, TASK-22
- **Guardian notes**: None
- **Description**: Assemble the IdeaCanvas page that combines the title editor, TipTap editor with auto-save, metadata panel, and (later) the AI chat panel into a responsive layout.
- **Acceptance criteria**:
  - IdeaCanvas component at /ideas/:id route
  - Three-column layout on desktop: editor (flex-1, centered), metadata panel (280px right)
  - Two-column stacked on tablet: editor full width, metadata below
  - Single column on mobile with collapsible metadata
  - Loads idea from IdeaRepository by route param :id
  - Shows 404 not-found if idea ID does not exist
  - Breadcrumb navigation: Ideas > [Idea Title]
  - Canvas header: title editor + status dropdown + save indicator
  - AI chat panel placeholder (right side, collapsed by default, implemented in Phase 4)
  - Delete idea button with ConfirmDialog before deletion
  - Keyboard shortcut: Escape returns to ideas dashboard
- **Files to create/modify**: src/features/canvas/components/idea-canvas.tsx, src/components/layouts/canvas-layout.tsx, src/features/canvas/index.ts
- **Technical notes**: The canvas layout is the most complex page in the app. Use CSS Grid or Flexbox for the multi-column layout. The AI chat panel area should be reserved in the layout but the actual panel component is built in Phase 4.

---

### TASK-24: Section Inserter

- **Epic**: EPIC-003 (Idea Canvas)
- **Priority**: P2
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-19
- **Guardian notes**: None
- **Description**: Implement the section inserter that allows users to insert structured section headings (Problem, Solution, Evidence, Next Steps) into the TipTap editor. Available via slash command or a button.
- **Acceptance criteria**:
  - Section inserter accessible via "/" slash command in empty paragraph or via toolbar button
  - Predefined sections: Problem Statement, Solution Approach, Key Evidence, Next Steps, Open Questions
  - Inserting a section adds an H2 heading with the section name plus an empty paragraph below
  - Section menu appears as a dropdown with icons for each section type
  - Sections are regular markdown headings -- not custom TipTap nodes (keeps content portable)
  - Slash command filters sections as user types (e.g., "/prob" shows "Problem Statement")
  - Keyboard navigation in the section menu (arrow keys + Enter)
- **Files to create/modify**: src/features/canvas/components/section-inserter.tsx
- **Technical notes**: The section inserter is a convenience feature -- it inserts standard markdown headings, not custom data structures. This keeps the content fully portable. The slash command pattern is familiar from tools like Notion.

---

## Phase 4: AI Integration (Weeks 5-8)

### TASK-25: AI Service Implementation

- **Epic**: EPIC-004 (AI Integration)
- **Priority**: P0
- **Estimated effort**: 6 hours
- **Dependencies**: TASK-05, TASK-06, TASK-12
- **Guardian notes**: WARN-04 (do NOT retry streaming requests -- only retry connection failures pre-stream). NOTE-06 (log warning for unknown model pricing, do not silently return 0).
- **Description**: Implement the AI service using Vercel AI SDK 4.x with provider abstraction, streaming support, context building, and cost tracking. This is the core AI integration layer.
- **Acceptance criteria**:
  - createAIService(deps: IAIServiceDeps) factory function per ADR Section 5.1
  - Provider abstraction: createAnthropic with anthropic-dangerous-direct-browser-access header, createOpenAI
  - chat() function: accepts idea, user message, history, onToken callback; returns response + usage
  - Context builder: buildContext(idea, history) creates system prompt with idea title, content (truncated at 5000 chars), status
  - System prompt matches ADR Section 4.5 exactly
  - Streaming: iterates result.textStream, calls onToken for each chunk
  - Cost tracker: calculateCost(model, inputTokens, outputTokens) with MODEL_PRICING table
  - Cost tracker logs console.warn for unknown models instead of silently returning 0 (NOTE-06 fix)
  - Saves interaction to AIInteractionRepository after completion
  - withRetry wraps ONLY the initial streamText() call, NOT the streaming iteration (WARN-04 fix)
  - AIServiceError thrown for provider errors with isRetryable flag
  - Timeout protection: 30s timeout for initial connection, no timeout for streaming
- **Files to create/modify**: src/features/ai-chat/services/ai-service.ts, src/features/ai-chat/services/context-builder.ts, src/features/ai-chat/services/cost-tracker.ts
- **Technical notes**: The WARN-04 fix is critical: withRetry must wrap only the connection/initial request, not the streaming iteration. If a stream fails mid-response, the error should surface to the UI rather than retrying (which would cause duplicate partial responses).

---

### TASK-26: AI Chat Panel UI

- **Epic**: EPIC-004 (AI Integration)
- **Priority**: P0
- **Estimated effort**: 6 hours
- **Dependencies**: TASK-02, TASK-09, TASK-25
- **Guardian notes**: None
- **Description**: Build the AI Chat Panel UI component with streaming message display, chat input, context indicator, and message history. This is the primary AI interaction surface.
- **Acceptance criteria**:
  - AIChatPanel: collapsible right panel in canvas layout (320px width)
  - Toggle button in canvas header to show/hide panel
  - Message list: user messages right-aligned, assistant messages left-aligned
  - Streaming display: assistant message grows in real-time as tokens arrive, batched with requestAnimationFrame
  - ChatMessage component: renders markdown in assistant messages, plain text for user messages
  - ChatInput: textarea with send button, Ctrl+Enter to send, disabled during streaming
  - Context indicator: shows which idea is being discussed (idea title + status badge)
  - Loading state: typing indicator animation while waiting for first token
  - Error state: error message with retry button on AI failure
  - Empty state: welcome message suggesting what to ask
  - Messages scroll to bottom automatically as new content arrives
  - Chat history per idea loaded from AISlice in Zustand store
- **Files to create/modify**: src/features/ai-chat/components/ai-chat-panel.tsx, src/features/ai-chat/components/chat-message.tsx, src/features/ai-chat/components/chat-input.tsx, src/features/ai-chat/components/context-indicator.tsx, src/features/ai-chat/hooks/use-ai-chat.ts, src/features/ai-chat/index.ts
- **Technical notes**: Streaming token rendering must be performant -- batch DOM updates with requestAnimationFrame to avoid re-rendering on every single token. The chat panel should feel responsive even during long AI responses.

---

### TASK-27: AI Chat Canvas Integration

- **Epic**: EPIC-004 (AI Integration)
- **Priority**: P0
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-23, TASK-26
- **Guardian notes**: None
- **Description**: Integrate the AI Chat Panel into the Idea Canvas layout. Connect the chat to the current idea context and persist chat history.
- **Acceptance criteria**:
  - AI Chat Panel renders in the canvas layout right column
  - Panel toggles via button in canvas header (icon: MessageSquare from Lucide)
  - Chat context automatically set to current idea when panel opens
  - Chat history persisted: closing and reopening panel preserves messages
  - Switching between ideas resets chat to that idea context and loads its history
  - AI interactions saved to database after each exchange via AIInteractionRepository
  - Panel resize handle or fixed width (320px desktop, full width mobile overlay)
  - Mobile: panel slides in as overlay from right edge
  - Panel open/closed state persists in UISlice
- **Files to create/modify**: src/features/canvas/components/idea-canvas.tsx (update), src/components/layouts/canvas-layout.tsx (update)
- **Technical notes**: The integration connects the AI Chat Panel to the canvas route. The current idea is passed as context to the AI service. Chat history is per-idea and loaded from the Zustand AISlice.

---

### TASK-28: AI Cost Display and Tracking

- **Epic**: EPIC-004 (AI Integration)
- **Priority**: P1
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-12, TASK-25, TASK-26
- **Guardian notes**: NOTE-06 (log warning for unknown model pricing).
- **Description**: Add cost tracking UI to the AI chat panel and settings page. Shows per-conversation and total cost with model breakdown.
- **Acceptance criteria**:
  - Cost badge in AI chat panel header: shows running cost for current conversation
  - Cost formatted to 4 decimal places for small amounts (e.g., /usr/bin/bash.0034)
  - Token count display: input tokens / output tokens for current conversation
  - Settings > AI section shows total all-time cost from AIInteractionRepository.getTotalCost()
  - Settings > AI section shows cost breakdown by model from getCostByModel()
  - Cost data refreshes when new AI interactions are saved
  - Tooltip on cost badge explains how cost is calculated
  - Unknown models show cost as "N/A" with note that pricing is unknown (NOTE-06)
- **Files to create/modify**: src/features/ai-chat/components/cost-display.tsx, src/features/settings/components/ai-cost-summary.tsx
- **Technical notes**: Cost tracking builds user trust by showing exactly what the AI usage costs. The pricing table is in cost-tracker.ts and should include a "last verified" date comment.

---

### TASK-29: Privacy Notice and AI Disclosure

- **Epic**: EPIC-004 (AI Integration)
- **Priority**: P1
- **Estimated effort**: 2 hours
- **Dependencies**: TASK-02, TASK-26
- **Guardian notes**: WARN-05 (honest disclosure about API key storage -- no fake encryption).
- **Description**: Implement the first-time privacy notice for AI features and the privacy section in Settings. Honestly disclose how API keys are stored and how data is sent to AI providers.
- **Acceptance criteria**:
  - First-time privacy notice: shown once when user first configures AI (before first API call)
  - Notice explains: API key stored in browser localStorage in plaintext (WARN-05 -- no fake encryption)
  - Notice explains: idea content is sent to the AI provider for processing
  - Notice explains: no data sent to any server except the chosen AI provider API
  - User must acknowledge notice before proceeding (checkbox + continue button)
  - Acknowledgment state stored in SettingsRepository
  - Settings > Privacy section: persistent version of the same disclosures
  - Settings > Privacy section: link to Anthropic and OpenAI privacy policies
  - Clear, non-technical language for all disclosures
- **Files to create/modify**: src/features/ai-chat/components/privacy-notice.tsx, src/features/settings/components/privacy-section.tsx
- **Technical notes**: Honest security disclosure is better than fake encryption (WARN-05). The notice should be clear, concise, and not alarmist -- the storage model is similar to other local-first AI tools like Cursor and Continue.dev.

---

## Phase 5: Search and Status (Weeks 8-9)

### TASK-30: FTS5 Search Service

- **Epic**: EPIC-005 (Search and Navigation)
- **Priority**: P0
- **Estimated effort**: 4 hours
- **Dependencies**: TASK-04, TASK-10, TASK-11
- **Guardian notes**: NOTE-08 (FTS5 sanitizer strips quotes, preventing phrase search -- document limitation).
- **Description**: Implement the search service using FTS5 full-text search combined with tag-based search. Includes query sanitization, result merging, and snippet generation.
- **Acceptance criteria**:
  - createSearchService(getDb) factory per ADR Section 5.3
  - search(query, limit=20): returns ISearchResult[] combining FTS5 and tag results
  - FTS5 search: queries ideas_fts with sanitized query, returns results with rank and snippets
  - Tag search: queries tags table with LIKE match, returns associated ideas
  - Result merging: deduplicates ideas appearing in both FTS5 and tag results
  - Results ranked: FTS5 rank for text matches, tag matches ranked lower
  - sanitizeFTSQuery: strips special chars, wraps terms in quotes with prefix wildcard
  - Snippet generation: uses FTS5 snippet() function with <mark> tags for highlighting
  - Minimum query length: 2 characters (shorter queries return empty)
  - Maximum results: configurable limit (default 20)
  - Search returns matchType field: title, content, or tag
  - Performance target: < 200ms for 1000 ideas
- **Files to create/modify**: src/features/search/services/search-service.ts
- **Technical notes**: The FTS5 query sanitization is critical for preventing SQL injection through the MATCH syntax. The sanitizer converts user input into safe quoted prefix terms. Phrase search is not supported (NOTE-08) -- document this limitation.

---

### TASK-31: Search UI

- **Epic**: EPIC-005 (Search and Navigation)
- **Priority**: P0
- **Estimated effort**: 5 hours
- **Dependencies**: TASK-02, TASK-09, TASK-18, TASK-30
- **Guardian notes**: None
- **Description**: Build the Search View with search input, real-time results, result highlighting, and navigation to ideas. Includes the Ctrl+K keyboard shortcut for quick access.
- **Acceptance criteria**:
  - SearchView component at /search route
  - Search input: large prominent input with search icon, autofocused on route enter
  - Real-time results: queries update as user types (debounced 200ms)
  - Results list: idea title, content snippet with highlighted matches (<mark> tags), status badge, tags
  - Click on result navigates to /ideas/:id
  - Empty state: search illustration with prompt text when no query entered
  - No results state: friendly message when query returns no matches
  - Result count displayed (e.g., "12 results for machine learning")
  - Keyboard shortcut: Ctrl+K opens search from anywhere in the app
  - Ctrl+K in search focuses the input
  - Keyboard navigation in results: arrow keys to highlight, Enter to navigate
  - Recent searches stored in UISlice (last 5 queries)
- **Files to create/modify**: src/features/search/components/search-view.tsx, src/features/search/components/search-input.tsx, src/features/search/components/search-results.tsx, src/features/search/hooks/use-search.ts, src/features/search/index.ts
- **Technical notes**: The search experience should feel instant. The 200ms debounce prevents excessive queries while still feeling responsive. Highlighted snippets use the <mark> tags from the FTS5 snippet() function, styled with Tailwind.

---

### TASK-32: Idea Deletion with Confirmation

- **Epic**: EPIC-005 (Search and Navigation)
- **Priority**: P1
- **Estimated effort**: 2 hours
- **Dependencies**: TASK-10, TASK-15, TASK-18, TASK-23
- **Guardian notes**: None
- **Description**: Implement idea deletion with a confirmation dialog. Available from the ideas dashboard (card menu) and the idea canvas. ON DELETE CASCADE handles cleanup of related records.
- **Acceptance criteria**:
  - Delete option in idea card dropdown menu (3-dot menu) on dashboard
  - Delete button in idea canvas metadata panel or header
  - ConfirmDialog shown before deletion: "Delete [idea title]? This cannot be undone."
  - On confirm: calls IdeaRepository.delete(id) + persist()
  - ON DELETE CASCADE in schema automatically cleans up idea_tags, connections, ai_interactions
  - After deletion: navigates back to /ideas dashboard, shows success toast
  - Error handling: shows error toast if deletion fails
  - Deletion from dashboard removes card with exit animation
- **Files to create/modify**: src/features/ideas/components/idea-card.tsx (update), src/features/canvas/components/idea-canvas.tsx (update)
- **Technical notes**: The confirmation dialog prevents accidental deletion. ON DELETE CASCADE in the schema (ADR Section 3.1) ensures all related records are cleaned up automatically -- no manual cleanup queries needed.

---

## Phase 6: Polish and Launch Prep (Weeks 10-12)

### TASK-33: Error Boundary Component

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P0
- **Estimated effort**: 2 hours
- **Dependencies**: TASK-02, TASK-06
- **Guardian notes**: None
- **Description**: Implement the React Error Boundary component per ADR Section 4.4. Catches uncaught errors in the component tree and shows a friendly fallback UI with recovery options.
- **Acceptance criteria**:
  - ErrorBoundary class component per ADR Section 4.4
  - Catches errors in child component tree via getDerivedStateFromError
  - Logs error details via componentDidCatch: message, stack, componentStack
  - Default fallback UI: "Something went wrong" message, "Your data is saved" reassurance, Refresh Page button
  - Custom fallback prop for feature-specific error UIs
  - ErrorBoundary wrapped at route level (each route gets its own boundary)
  - Additional ErrorBoundary around AI chat panel (AI errors do not crash the editor)
  - Reset error state when navigating to a different route
- **Files to create/modify**: src/components/error-boundary.tsx
- **Technical notes**: The error boundary is a safety net. It should reassure users that their data is safe (it is -- data is in IndexedDB) and provide a simple recovery action. Feature-specific boundaries (e.g., around the AI panel) prevent one feature crashing another.

---

### TASK-34: Keyboard Shortcuts System

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P1
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-07, TASK-17, TASK-31
- **Guardian notes**: None
- **Description**: Implement the global keyboard shortcuts system and the shortcuts cheat sheet. Provides power-user efficiency for common actions.
- **Acceptance criteria**:
  - useKeyboardShortcuts hook: listens for keyboard events at document level
  - Ctrl+N / Cmd+N: open Spark Capture modal
  - Ctrl+K / Cmd+K: open/focus Search
  - Escape: close current modal/panel, or navigate back from canvas to dashboard
  - Ctrl+Enter / Cmd+Enter: submit form in active modal
  - Shortcuts do NOT fire when user is typing in an input/textarea (except Escape)
  - Shortcuts cheat sheet: shows all available shortcuts in a popover or modal
  - Cheat sheet accessible via "?" key or help button
  - Shortcuts registered/unregistered on mount/unmount to prevent memory leaks
  - Platform-aware: shows Cmd on macOS, Ctrl on Windows/Linux
- **Files to create/modify**: src/hooks/use-keyboard-shortcuts.ts, src/features/shortcuts/keyboard-shortcuts-help.tsx
- **Technical notes**: Keyboard shortcuts must not conflict with browser defaults or TipTap editor shortcuts. Only fire shortcuts when not focused on text input elements (except Escape which always works).

---

### TASK-35: Onboarding Flow

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P1
- **Estimated effort**: 4 hours
- **Dependencies**: TASK-14, TASK-17, TASK-23
- **Guardian notes**: None
- **Description**: Implement the 3-step onboarding flow for new users. Guides them through capturing their first spark, exploring the canvas, and optionally setting up AI.
- **Acceptance criteria**:
  - Onboarding triggers on first app visit (no ideas exist, no onboarding_completed setting)
  - Step 1: Welcome + capture first spark (pre-filled spark capture modal with example title)
  - Step 2: Brief tour of the canvas (highlight editor, metadata, AI panel toggle)
  - Step 3: Optional AI setup (skip or configure API key)
  - Progress indicator: 3 dots showing current step
  - Skip button available at every step
  - Onboarding completion stored in SettingsRepository (onboarding_completed: true)
  - Does not show again after completion or skip
  - OnboardingService tracks state and progression logic
  - Target: new user reaches first value (saved spark) in < 3 minutes
- **Files to create/modify**: src/features/onboarding/components/onboarding-flow.tsx, src/features/onboarding/components/onboarding-tooltip.tsx, src/features/onboarding/services/onboarding-service.ts, src/features/onboarding/index.ts
- **Technical notes**: The onboarding should feel lightweight, not like a mandatory tutorial. Each step should be completable in under 60 seconds. The goal is to get the user to their first saved spark as quickly as possible.

---

### TASK-36: Export Service

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P0
- **Estimated effort**: 4 hours
- **Dependencies**: TASK-10, TASK-11, TASK-06
- **Guardian notes**: None
- **Description**: Implement the export service supporting JSON and Markdown export formats. Users can export individual ideas or all ideas. Data portability from day 1.
- **Acceptance criteria**:
  - ExportService with exportToJSON(ideas) and exportToMarkdown(ideas) methods
  - JSON export: full idea data including tags, metadata, timestamps in structured JSON
  - Markdown export: each idea as a markdown document with YAML frontmatter (title, status, tags, dates)
  - Single idea export: exports one idea to chosen format
  - Bulk export: exports all ideas as a zip file (markdown) or single JSON array
  - Export includes tags associated with each idea
  - File download triggered via Blob URL + anchor click pattern
  - Filename includes date: ideaforge-export-2026-02-12.json or .md
  - ExportError thrown with context on failures
  - Database backup export: raw db.export() Uint8Array for full database backup
- **Files to create/modify**: src/features/export/services/export-service.ts, src/features/export/services/json-exporter.ts, src/features/export/services/markdown-exporter.ts, src/features/export/index.ts
- **Technical notes**: Export is a P0 feature -- users must be able to extract their data from day 1. The markdown format should be clean and readable in any markdown editor. The JSON format should be structured for potential re-import in future versions.

---

### TASK-37: Export Dialog UI

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P0
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-15, TASK-36
- **Guardian notes**: None
- **Description**: Build the export dialog UI accessible from Settings and from the idea canvas. Allows users to choose format and scope of export.
- **Acceptance criteria**:
  - Export dialog using Modal component
  - Format selection: JSON or Markdown radio buttons
  - Scope selection: Current idea (when in canvas) or All ideas
  - Preview section showing what will be exported (idea count, total size estimate)
  - Export button triggers ExportService and file download
  - Success toast after export completes
  - Error handling with retry option
  - Accessible from: Settings > Data Management, Idea Canvas > dropdown menu
  - Database backup option: exports raw .sqlite file
- **Files to create/modify**: src/features/export/components/export-dialog.tsx
- **Technical notes**: The export dialog should make it clear what the user is exporting and in what format. The preview helps users confirm before downloading.

---

### TASK-38: Settings Page

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P0
- **Estimated effort**: 5 hours
- **Dependencies**: TASK-05, TASK-11, TASK-14, TASK-15, TASK-28, TASK-29, TASK-37
- **Guardian notes**: WARN-05 (store API keys in plaintext localStorage with honest disclosure).
- **Description**: Build the Settings page with AI configuration, data management, and privacy sections. This is the central configuration hub for the application.
- **Acceptance criteria**:
  - SettingsView component at /settings route
  - AI Configuration section: provider dropdown (Anthropic/OpenAI), API key input (password field), model selection
  - AI key stored in plaintext localStorage with clear disclosure label (WARN-05 -- no fake encryption)
  - API key validation: test connection button that sends a minimal request to verify the key works
  - Data Management section: export all data, database backup download, import (future -- disabled for MVP)
  - Clear All Data: requires typing DELETE in a confirmation input to prevent accidental data loss
  - Clear All Data deletes: IndexedDB database, all backups, localStorage settings
  - AI cost summary: total cost, cost by model breakdown (from TASK-28)
  - Privacy section: data handling disclosures, API provider links (from TASK-29)
  - Theme selection: Dark (default), Light, System
  - Settings saved immediately on change via SettingsRepository
  - Success/error toast on save
- **Files to create/modify**: src/features/settings/components/settings-view.tsx, src/features/settings/components/ai-config-section.tsx, src/features/settings/components/data-management-section.tsx, src/features/settings/index.ts
- **Technical notes**: The settings page is critical for AI setup. The API key input should be a password field (dots) with a show/hide toggle. The Clear All Data confirmation prevents accidental data loss -- this is a destructive action that cannot be undone.

---

### TASK-39: Theme System

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P1
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-02, TASK-11
- **Guardian notes**: None
- **Description**: Implement the theme system supporting Dark (default), Light, and System (OS preference) modes. Theme preference persists across sessions.
- **Acceptance criteria**:
  - useTheme hook: getTheme, setTheme, resolvedTheme (actual active theme)
  - Three options: dark (default), light, system (follows OS prefers-color-scheme)
  - Theme applied via class on <html> element (dark/light)
  - CSS custom properties in globals.css switch based on theme class
  - Theme preference stored in SettingsRepository
  - System theme reacts to OS preference changes in real-time via matchMedia listener
  - Theme toggle accessible in Settings page and optionally in header
  - No flash of wrong theme on page load (theme applied before first render)
  - All components already use design tokens from TASK-02 that respond to theme class
- **Files to create/modify**: src/hooks/use-theme.ts, src/styles/globals.css (update)
- **Technical notes**: The theme system builds on the design tokens from TASK-02. The dark/light mode CSS custom properties are already defined -- this task adds the switching logic and persistence. Apply theme class on <html> element before React hydration to prevent flash.

---

### TASK-40: Skeleton and Loading States

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P1
- **Estimated effort**: 3 hours
- **Dependencies**: TASK-02, TASK-07, TASK-18, TASK-23
- **Guardian notes**: WARN-11 (Skeleton listed as Future in design system but needed for MVP). WARN-12 (skeleton during WASM init).
- **Description**: Implement skeleton loading components for all major views. Provides visual feedback during data loading and WASM initialization.
- **Acceptance criteria**:
  - Skeleton component: base shimmer animation component (per WARN-11 -- build during feature task)
  - SkeletonCard: matches IdeaCard dimensions for dashboard loading state
  - SkeletonEditor: matches canvas editor layout for idea loading state
  - SkeletonList: matches search results layout
  - AppSkeleton: full-page skeleton shown during sql.js WASM initialization (WARN-12)
  - Skeleton animations use CSS only (no JS animation overhead)
  - Skeletons match actual content dimensions to minimize layout shift
  - Loading states integrated into: Ideas Dashboard, Idea Canvas, Search View
  - Suspense fallback components use appropriate skeletons per route
- **Files to create/modify**: src/components/ui/skeleton.tsx, src/components/layouts/loading-skeleton.tsx (update), src/features/ideas/components/skeleton-card.tsx, src/features/canvas/components/skeleton-editor.tsx
- **Technical notes**: Skeletons should closely match the shape of the actual content they replace. This reduces perceived loading time and prevents layout shift when content loads. The WASM init skeleton is especially important as it is seen on every page load.

---

### TASK-41: CI/CD Pipeline and Build Optimization

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P1
- **Estimated effort**: 4 hours
- **Dependencies**: TASK-01, TASK-13
- **Guardian notes**: NOTE-01 (bundle size budget may be tight -- measure actual sizes).
- **Description**: Set up the GitHub Actions CI/CD pipeline per ADR Section 8.3 and optimize the production build for bundle size targets.
- **Acceptance criteria**:
  - GitHub Actions workflow: .github/workflows/ci.yml per ADR Section 8.3
  - CI jobs: lint, typecheck, unit tests, build, bundle size check
  - E2E test job: installs Playwright, builds, runs e2e tests
  - Bundle size check: fails if dist/ exceeds 5MB total
  - Manual chunks verified: vendor-react, vendor-editor, vendor-ai, vendor-ui per ADR Section 2.10
  - Each chunk within budget: vendor-react < 45KB, vendor-editor < 80KB, vendor-ai < 30KB, vendor-ui < 25KB gzipped
  - sql.js WASM file served correctly from public/sql.js/
  - Source maps generated for debugging but excluded from size budget
  - Build target: es2022 per ADR
  - Deployment config: Vercel-ready with correct output directory (dist/)
  - package.json scripts verified: dev, build, lint, typecheck, test, test:unit, test:e2e
- **Files to create/modify**: .github/workflows/ci.yml, vite.config.ts (update if needed), package.json (update scripts)
- **Technical notes**: The CI pipeline ensures code quality on every push. Bundle size measurement should happen early to catch regressions. If actual bundle sizes exceed budgets, investigate tree-shaking and lazy loading opportunities (NOTE-01).

---

### TASK-42: E2E Tests for Critical Flows

- **Epic**: EPIC-006 (Export, Settings, and Polish)
- **Priority**: P0
- **Estimated effort**: 6 hours
- **Dependencies**: TASK-17, TASK-23, TASK-26, TASK-31, TASK-38
- **Guardian notes**: None
- **Description**: Write Playwright E2E tests covering all critical user flows per ADR Section 9.4. These are the final confidence gate before launch.
- **Acceptance criteria**:
  - Spark capture flow: open modal, fill form, save, verify toast and dashboard card
  - Idea canvas flow: navigate to idea, edit title, edit content, verify auto-save indicator
  - AI chat flow (mocked): open panel, send message, verify streaming response appears (mock AI provider)
  - Search flow: navigate to search, type query, verify results appear with highlights
  - Settings flow: navigate to settings, configure AI provider, verify save
  - Export flow: trigger export from settings, verify file downloads
  - Delete flow: delete idea from dashboard, confirm dialog, verify removal
  - Onboarding flow: fresh state triggers onboarding, can complete all 3 steps
  - Theme switching: toggle dark/light, verify visual change persists after reload
  - Keyboard shortcuts: Ctrl+N opens spark modal, Ctrl+K opens search, Escape closes modal
  - Error recovery: error boundary catches error, shows fallback, refresh recovers
  - Tests run in Chromium (primary), Firefox, and WebKit via Playwright
  - AI responses mocked using Playwright route interception
- **Files to create/modify**: e2e/spark-capture.spec.ts, e2e/idea-canvas.spec.ts, e2e/ai-chat.spec.ts, e2e/search.spec.ts, e2e/settings.spec.ts, e2e/export.spec.ts, e2e/onboarding.spec.ts, e2e/keyboard-shortcuts.spec.ts, playwright.config.ts
- **Technical notes**: E2E tests must use Playwright route interception to mock AI API calls -- never make real API calls in tests. Use data-testid attributes for stable selectors. Tests should be independent and not rely on execution order.

---

## Summary

### Priority Summary

| Priority | Count | Tasks |
|----------|-------|-------|
| P0 | 28 | 01-10, 13-15, 17-20, 23, 25-26, 27, 30-31, 33, 36-38, 42 |
| P1 | 12 | 11-12, 21-22, 28-29, 32, 34-35, 39-41 |
| P2 | 2 | 24 |

### Phase Summary

| Phase | Weeks | Tasks | Estimated Hours |
|-------|-------|-------|-----------------|
| Phase 1: Foundation | 1-2 | TASK-01 to TASK-13 | 46 hours |
| Phase 2: Spark Capture | 2-3 | TASK-14 to TASK-18 | 19 hours |
| Phase 3: Idea Canvas | 3-5 | TASK-19 to TASK-24 | 21 hours |
| Phase 4: AI Integration | 5-8 | TASK-25 to TASK-29 | 20 hours |
| Phase 5: Search and Status | 8-9 | TASK-30 to TASK-32 | 11 hours |
| Phase 6: Polish and Launch Prep | 10-12 | TASK-33 to TASK-42 | 37 hours |
| **Total** | **1-12** | **42 tasks** | **~154 hours** |

### Critical Path

The critical path determines the minimum time to completion. Tasks on this path cannot be delayed without delaying the entire project.

```
TASK-01 Scaffolding [3h]
  -> TASK-04 Database Manager [8h]
    -> TASK-10 Idea Repository [5h]
      -> TASK-13 Foundation Tests [5h]
        -> TASK-17 Spark Capture Modal [4h]
          -> TASK-18 Ideas Dashboard [6h]
            -> TASK-23 Canvas Layout [4h]
              -> TASK-27 AI Chat Integration [3h]
                -> TASK-31 Search UI [5h]
                  -> TASK-42 E2E Tests [6h]
```





Critical path length: ~57 hours (10 tasks)

### Parallelization Opportunities

Several task groups can be executed in parallel to reduce total wall-clock time:

```
Phase 1 Parallel Groups:
  Group A: TASK-02, TASK-03, TASK-06, TASK-08
    All depend only on TASK-01, can run simultaneously.

  Group B: TASK-05 depends on TASK-03 only.
    Can start as soon as TASK-03 completes, parallel with TASK-04.

  Group C: TASK-11 + TASK-12
    Both depend on TASK-10, can run in parallel.

Phase 4 Parallel Groups:
  TASK-25 and TASK-26 can be partially parallelized.
  UI can be built with mocked data while service is implemented.

Phase 6 Parallel Groups:
  TASK-33 + TASK-34 + TASK-36 + TASK-39 can all run in parallel.
```





### Dependency Map

| Task | Depends On | Blocks |
|------|-----------|--------|
| TASK-01 | None | 02,03,04,06,07,08 |
| TASK-02 | 01 | 07,14,15,16,26,29,33,39,40 |
| TASK-03 | 01 | 04,05,09 |
| TASK-04 | 01,03 | 07,09,13,30 |
| TASK-05 | 03 | 10,25,38 |
| TASK-06 | 01 | 13,25,33,36 |
| TASK-07 | 01,02,04 | 23,34,40 |
| TASK-08 | 01 | 09,10 |
| TASK-09 | 03,04,08 | 14,17,18,26,31 |
| TASK-10 | 03,04,05,08 | 11,12,13,17,18,20,21,30,32,36 |
| TASK-11 | 10 | 13,16,18,22,30,36,38,39 |
| TASK-12 | 10 | 13,25,28 |
| TASK-13 | 04,05,06,10,11,12 | 41 |
| TASK-14 | 02,07,09 | 17,18,35,38 |
| TASK-15 | 02 | 17,32,37,38 |
| TASK-16 | 02,11 | 17,22 |
| TASK-17 | 09,10,14,15,16 | 18,34,35,42 |
| TASK-18 | 09,10,11,14,17 | 23,32,40 |
| TASK-19 | 01,02 | 20,21,23,24 |
| TASK-20 | 10,19 | 23 |
| TASK-21 | 10,19 | 22,23 |
| TASK-22 | 11,16,21 | 23 |
| TASK-23 | 07,19,20,21,22 | 27,32,35,40,42 |
| TASK-24 | 19 | None |
| TASK-25 | 05,06,12 | 26,27,28 |
| TASK-26 | 02,09,25 | 27,28,42 |
| TASK-27 | 23,26 | 42 |
| TASK-28 | 12,25,26 | 38 |
| TASK-29 | 02,26 | 38 |
| TASK-30 | 04,10,11 | 31 |
| TASK-31 | 02,09,18,30 | 34,42 |
| TASK-32 | 10,15,18,23 | None |
| TASK-33 | 02,06 | None |
| TASK-34 | 07,17,31 | None |
| TASK-35 | 14,17,23 | None |
| TASK-36 | 10,11,06 | 37 |
| TASK-37 | 15,36 | 38 |
| TASK-38 | 05,11,14,15,28,29,37 | 42 |
| TASK-39 | 02,11 | None |
| TASK-40 | 02,07,18,23 | None |
| TASK-41 | 01,13 | None |
| TASK-42 | 17,23,26,31,38 | None |

---

*Generated by apex-task-decomposer from ADR v1.0 with guardian analysis applied.*
